{"version":3,"file":"logout.js","sourceRoot":"","sources":["../../src/handlers/logout.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAA;AAEhD,kCAAkC;AAClC,SAAS,YAAY,CAAC,GAAY;IAChC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAA;IAC5E,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAA;AACxB,CAAC;AAED,qBAAqB;AACrB,KAAK,UAAU,cAAc,CAC3B,KAA2B,EAC3B,OAAsB,EACtB,GAAmD;IAEnD,MAAM,KAAK,GACT,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,aAAa,CAAA;IACjF,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,UAAU;QAAE,OAAM;IAErC,uCAAuC;IACvC,MAAM,MAAM,GAAG,IAAI,eAAe,CAAC;QACjC,KAAK;QACL,eAAe,EAAE,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,eAAe;QACtE,SAAS,EAAE,GAAG,CAAC,SAAS;KACzB,CAAC,CAAA;IACF,IAAI,GAAG,CAAC,aAAa;QAAE,MAAM,CAAC,GAAG,CAAC,eAAe,EAAE,GAAG,CAAC,aAAa,CAAC,CAAA;IAErE,2CAA2C;IAC3C,MAAM,KAAK,CAAC,GAAG,CAAC,UAAU,EAAE;QAC1B,MAAM,EAAE,MAAM;QACd,OAAO,EAAE,EAAE,cAAc,EAAE,mCAAmC,EAAE;QAChE,IAAI,EAAE,MAAM;KACb,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,CAAA,CAAC,sBAAsB;AAC/C,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,YAAY,CAChC,OAAgB,EAChB,GAAsC,EACtC,SAA2B;IAE3B,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;IAChC,MAAM,UAAU,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAGpD,CAAA;IAEV,MAAM,SAAS,GAAG,YAAY,CAAC,OAAO,CAAC,CAAA;IACvC,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,kBAAkB;QAClB,OAAO,YAAY,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,CAAA;IACnC,CAAC;IAED,MAAM,GAAG,GAAG,QAAQ,SAAS,EAAE,CAAA;IAC/B,MAAM,WAAW,GAAG,MAAM,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;IAC/C,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,6BAA6B;QAC7B,OAAO,YAAY,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,CAAA;IACnC,CAAC;IAED,QAAQ;IACR,IAAI,OAAsB,CAAA;IAC1B,IAAI,CAAC;QACH,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAkB,CAAA;IACpD,CAAC;IAAC,MAAM,CAAC;QACP,sBAAsB;QACtB,MAAM,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAC9B,OAAO,YAAY,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,CAAA;IACnC,CAAC;IAED,aAAa;IACb,MAAM,GAAG,GAAG,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAmD,CAAA;IACzF,IAAI,GAAG,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;QACzB,IAAI,CAAC;YACH,IAAI,UAAU,KAAK,QAAQ,IAAI,UAAU,KAAK,MAAM,EAAE,CAAC;gBACrD,MAAM,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE,GAAG,CAAC,CAAA;YAC9C,CAAC;YACD,IAAI,UAAU,KAAK,SAAS,IAAI,UAAU,KAAK,MAAM,EAAE,CAAC;gBACtD,MAAM,cAAc,CAAC,SAAS,EAAE,OAAO,EAAE,GAAG,CAAC,CAAA;YAC/C,CAAC;QACH,CAAC;QAAC,MAAM,CAAC;YACP,2BAA2B;QAC7B,CAAC;IACH,CAAC;IAED,eAAe;IACf,MAAM,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;IAE9B,6CAA6C;IAC7C,iCAAiC;IACjC,OAAO,YAAY,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,CAAA;AACnC,CAAC","sourcesContent":["import { KVNamespace } from '@cloudflare/workers-types'\nimport { OAuth2ProviderConfig, ProviderRegistry } from '../types/provider'\nimport { SessionRecord } from '../types/session'\nimport { jsonWithCors } from '../utils/response'\n\n// Authorization 헤더에서 sessionId 추출\nfunction getSessionId(req: Request): string | null {\n  const m = (req.headers.get('authorization') || '').match(/^Bearer\\s+(.+)$/i)\n  return m ? m[1] : null\n}\n\n// RFC 7009 토큰 무효화 시도\nasync function tryRevokeToken(\n  which: 'access' | 'refresh',\n  session: SessionRecord,\n  cfg: OAuth2ProviderConfig & { revoke_url?: string }\n) {\n  const token =\n    which === 'access' ? session.token?.access_token : session.token?.refresh_token\n  if (!token || !cfg.revoke_url) return\n\n  // 일부 공급자는 client_secret이 필수/선택 다를 수 있음\n  const params = new URLSearchParams({\n    token,\n    token_type_hint: which === 'access' ? 'access_token' : 'refresh_token',\n    client_id: cfg.client_id,\n  })\n  if (cfg.client_secret) params.set('client_secret', cfg.client_secret)\n\n  // 메모: 어떤 공급자는 Basic Auth를 요구하기도 함(필요 시 추가)\n  await fetch(cfg.revoke_url, {\n    method: 'POST',\n    headers: { 'content-type': 'application/x-www-form-urlencoded' },\n    body: params,\n  }).catch(() => void 0) // 실패해도 로그아웃 자체는 계속 진행\n}\n\n/**\n * POST /oauth2/logout[?revoke=access|refresh|both]\n * - Authorization: Bearer <sessionId> 필수(없어도 200 ok로 처리하여 idempotent)\n * - 세션 삭제, (선택) 공급자 토큰 무효화 시도\n */\nexport async function oauth2Logout(\n  request: Request,\n  env: { SESSIONS: KVNamespace<string> },\n  providers: ProviderRegistry\n): Promise<Response> {\n  const url = new URL(request.url)\n  const revokeMode = (url.searchParams.get('revoke') || 'access') as\n    | 'access'\n    | 'refresh'\n    | 'both'\n\n  const sessionId = getSessionId(request)\n  if (!sessionId) {\n    // 이미 로그아웃된 상태로 간주\n    return jsonWithCors({ ok: true })\n  }\n\n  const key = `sess:${sessionId}`\n  const sessionJson = await env.SESSIONS.get(key)\n  if (!sessionJson) {\n    // 없는 세션 → 역시 성공으로 응답(멱등성 보장)\n    return jsonWithCors({ ok: true })\n  }\n\n  // 세션 로드\n  let session: SessionRecord\n  try {\n    session = JSON.parse(sessionJson) as SessionRecord\n  } catch {\n    // 파싱 실패하더라도 세션 삭제만 진행\n    await env.SESSIONS.delete(key)\n    return jsonWithCors({ ok: true })\n  }\n\n  // 공급자 토큰 무효화\n  const cfg = providers[session.provider] as OAuth2ProviderConfig & { revoke_url?: string }\n  if (cfg && session.token) {\n    try {\n      if (revokeMode === 'access' || revokeMode === 'both') {\n        await tryRevokeToken('access', session, cfg)\n      }\n      if (revokeMode === 'refresh' || revokeMode === 'both') {\n        await tryRevokeToken('refresh', session, cfg)\n      }\n    } catch {\n      // 토큰 무효화 실패는 무시(세션 삭제는 계속)\n    }\n  }\n\n  // 서버 세션 삭제(핵심)\n  await env.SESSIONS.delete(key)\n\n  // 클라이언트는 localStorage의 sid를 삭제해야 함(프론트에서 처리)\n  // 원하는 경우 회전/삭제 신호를 헤더로 전달할 수도 있음\n  return jsonWithCors({ ok: true })\n}\n"]}